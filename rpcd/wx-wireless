#!/bin/sh

# wx-wireless - OpenWRT ubus RPC服务
# 提供无线中继管理的RPC接口
# 放置于 /usr/libexec/rpcd/wx-wireless

. /usr/share/libubox/jshn.sh # 加载jshn库

# --- 基础路径配置 ---
CONFIG_DIR="/etc/wx"
CONFIG_FILE="$CONFIG_DIR/wifi-config.json"
LOG_FILE="$CONFIG_DIR/wx-wireless.log"
SETTINGS_FILE="$CONFIG_DIR/wx_settings.conf"

# === 硬编码配置 (不开放给前端配置) ===
TOKEN_EXPIRY=3600                     # 登录Token有效期 (秒)
MAX_FAIL=10                           # 密码错误锁定次数
LOCK_TIME=3600                        # 锁定时长 (秒)
SHOW_WXPUSHER=1                       # 显示消息推送配置 (1=显示, 0=隐藏)
MAX_LOG_SIZE=102400                   # 日志最大大小 (Bytes)
CHECK_WAIT_TIME=3                     # 检测循环等待间隔 (秒)
REBOOT_DELAY_TIME=3                   # 触发重启前的缓冲时间 (秒)

# 加载用户配置文件
if [ ! -f "$SETTINGS_FILE" ]; then
    echo '{"error":"配置文件不存在: '"$SETTINGS_FILE"'"}'
    exit 1
fi
. "$SETTINGS_FILE"


# 日志记录函数（带自动轮转）
log_message() {
    local log_entry="$(date "+%Y-%m-%d %H:%M:%S") - $1"
    
    # 检查日志文件大小，超过100KB则保留最后50行
    if [ -f "$LOG_FILE" ]; then
        local log_size=$(wc -c < "$LOG_FILE" 2>/dev/null || echo 0)
        if [ "$log_size" -gt "$MAX_LOG_SIZE" ]; then
            local tmp_file=$(mktemp)
            tail -n 50 "$LOG_FILE" > "$tmp_file"
            mv "$tmp_file" "$LOG_FILE"
        fi
    fi
    
    echo "$log_entry" >> "$LOG_FILE"
}

# 确保配置文件存在
init_config() {
    if [ ! -d "$CONFIG_DIR" ]; then
        mkdir -p "$CONFIG_DIR"
    fi
    if [ ! -f "$CONFIG_FILE" ]; then
        echo '{"wifi":[],"autowifiranking":[{"CQ_TIMES":0}]}' > "$CONFIG_FILE"
    fi
}

# ========== JSON 辅助函数 (替代 jq，兼容 OpenWRT) ==========

# 获取 wifi 数组长度
json_get_wifi_count() {
    local output=$(jsonfilter -i "$CONFIG_FILE" -e '@.wifi[*].name' 2>/dev/null)
    if [ -z "$output" ]; then
        echo "0"
    else
        echo "$output" | wc -l
    fi
}

# 获取 wifi 数组中指定索引的字段值
# 参数: $1=索引 $2=字段名
json_get_wifi_field() {
    local idx="$1"
    local field="$2"
    jsonfilter -i "$CONFIG_FILE" -e "@.wifi[$idx].$field" 2>/dev/null
}

# 获取 CQ_TIMES 值
json_get_cq_times() {
    jsonfilter -i "$CONFIG_FILE" -e '@.autowifiranking[0].CQ_TIMES' 2>/dev/null || echo "0"
}

# 设置 CQ_TIMES 值
json_set_cq_times() {
    local value="$1"
    sed -i "s/\"CQ_TIMES\":[0-9]*/\"CQ_TIMES\":$value/" "$CONFIG_FILE"
}

# 更新 wifi 数组中指定索引的 last_updated 字段
# 参数: $1=索引 $2=时间戳
json_update_wifi_timestamp() {
    local target_idx="$1"
    local timestamp="$2"
    local cq_times=$(json_get_cq_times)
    local total=$(json_get_wifi_count)
    
    # 重建配置文件（更新指定索引的时间戳）
    local new_wifi="["
    local count=0
    local i=0
    while [ $i -lt $total ]; do
        local n=$(json_get_wifi_field $i "name")
        local e=$(json_get_wifi_field $i "encryption")
        local p=$(json_get_wifi_field $i "password")
        local b=$(json_get_wifi_field $i "band")
        local t=$(json_get_wifi_field $i "last_updated")
        
        # 更新目标索引的时间戳
        [ $i -eq $target_idx ] && t="$timestamp"
        
        [ $count -gt 0 ] && new_wifi="$new_wifi,"
        new_wifi="$new_wifi{\"name\":\"$n\",\"encryption\":\"$e\",\"password\":\"$p\",\"band\":\"$b\",\"last_updated\":\"$t\"}"
        count=$((count + 1))
        i=$((i + 1))
    done
    new_wifi="$new_wifi]"
    
    echo "{\"wifi\":$new_wifi,\"autowifiranking\":[{\"CQ_TIMES\":$cq_times}]}" > "$CONFIG_FILE"
}

# 保存或更新 wifi 热点
# 参数: $1=name $2=encryption $3=password $4=band $5=last_updated
json_save_wifi() {
    local name="$1"
    local encryption="$2"
    local password="$3"
    local band="$4"
    local last_updated="$5"
    
    # 读取现有配置并重建
    local cq_times=$(json_get_cq_times)
    local wifi_count=$(json_get_wifi_count)
    local new_wifi="["
    local found=0
    local count=0
    
    # 遍历现有热点
    local i=0
    while [ $i -lt $wifi_count ]; do
        local n=$(json_get_wifi_field $i "name")
        local e=$(json_get_wifi_field $i "encryption")
        local p=$(json_get_wifi_field $i "password")
        local b=$(json_get_wifi_field $i "band")
        local t=$(json_get_wifi_field $i "last_updated")
        
        if [ "$n" = "$name" ]; then
            # 更新现有记录
            e="$encryption"
            p="$password"
            b="$band"
            t="$last_updated"
            found=1
        fi
        
        [ $count -gt 0 ] && new_wifi="$new_wifi,"
        new_wifi="$new_wifi{\"name\":\"$n\",\"encryption\":\"$e\",\"password\":\"$p\",\"band\":\"$b\",\"last_updated\":\"$t\"}"
        count=$((count + 1))
        i=$((i + 1))
    done
    
    # 如果是新记录，添加到末尾
    if [ $found -eq 0 ]; then
        [ $count -gt 0 ] && new_wifi="$new_wifi,"
        new_wifi="$new_wifi{\"name\":\"$name\",\"encryption\":\"$encryption\",\"password\":\"$password\",\"band\":\"$band\",\"last_updated\":\"$last_updated\"}"
    fi
    
    new_wifi="$new_wifi]"
    
    # 重写配置文件
    echo "{\"wifi\":$new_wifi,\"autowifiranking\":[{\"CQ_TIMES\":$cq_times}]}" > "$CONFIG_FILE"
}

# 删除 wifi 热点
# 参数: $1=name
json_delete_wifi() {
    local name="$1"
    local cq_times=$(json_get_cq_times)
    local total=$(json_get_wifi_count)
    
    # 重建配置文件（排除指定热点）
    local new_wifi="["
    local count=0
    local i=0
    while [ $i -lt $total ]; do
        local n=$(json_get_wifi_field $i "name")
        if [ "$n" != "$name" ]; then
            [ $count -gt 0 ] && new_wifi="$new_wifi,"
            local e=$(json_get_wifi_field $i "encryption")
            local p=$(json_get_wifi_field $i "password")
            local b=$(json_get_wifi_field $i "band")
            local t=$(json_get_wifi_field $i "last_updated")
            new_wifi="$new_wifi{\"name\":\"$n\",\"encryption\":\"$e\",\"password\":\"$p\",\"band\":\"$b\",\"last_updated\":\"$t\"}"
            count=$((count + 1))
        fi
        i=$((i + 1))
    done
    new_wifi="$new_wifi]"
    
    echo "{\"wifi\":$new_wifi,\"autowifiranking\":[{\"CQ_TIMES\":$cq_times}]}" > "$CONFIG_FILE"
}

# 重写 wifi 数组（用于排序）
# 参数: $1=新的wifi JSON数组字符串
json_rewrite_wifi() {
    local new_wifi="$1"
    local cq_times=$(json_get_cq_times)
    echo "{\"wifi\":$new_wifi,\"autowifiranking\":[{\"CQ_TIMES\":$cq_times}]}" > "$CONFIG_FILE"
}

# 检查网络连通性
check_connectivity() {
    ping -c 1 -W 2 "$PING_TARGET" >/dev/null 2>&1
    return $?
}

# 获取无线 STA 配置段名称（兼容mode=sta和mode='sta'两种格式）
get_sta_section() {
    uci show wireless | grep -E "mode='?sta'?" | head -1 | cut -d. -f2
}

# 校验 WiFi 密码 (只允许可见 ASCII 字符, 8-63位)
validate_password() {
    local pwd="$1"
    # 长度检查
    local len=${#pwd}
    if [ "$len" -lt 8 ] || [ "$len" -gt 63 ]; then
        return 1
    fi
    # 字符检查：使用 grep 检查是否只包含 ASCII 32-126
    if printf "%s" "$pwd" | grep -q '[^ -~]'; then
        return 1
    fi
    return 0
}

# 动态获取唯一STA接口的network名称
# 使用jsonfilter方式，性能更好
# 返回: 成功返回network名(如wwan)，失败返回空
# 全局变量 STA_NETWORK_COUNT 记录STA接口数量
get_single_sta_network() {
    local wireless_status=$(ubus call network.wireless status 2>/dev/null)
    
    # 统计STA接口数量
    STA_NETWORK_COUNT=$(echo "$wireless_status" | jsonfilter -e '@.*.interfaces[@.config.mode="sta"]' 2>/dev/null | grep -c '"section"')
    
    if [ "$STA_NETWORK_COUNT" -eq 1 ]; then
        # 只有1个STA时返回其network名称
        echo "$wireless_status" | jsonfilter -e '@.*.interfaces[@.config.mode="sta"].config.network[0]' 2>/dev/null
    fi
}

# 获取无线状态
get_status() {
    local sta_info sta_ssid sta_key sta_band sta_network sta_ifname bridge_status network_status
    local wireless_status sta_count relay_enabled sta_section
    
    # 获取wireless状态并统计STA接口数量
    wireless_status=$(ubus call network.wireless status 2>/dev/null)
    sta_count=$(echo "$wireless_status" | jsonfilter -e '@.*.interfaces[@.config.mode="sta"]' 2>/dev/null | grep -c '"section"')
    
    # 获取所有STA接口信息
    local all_sta_info=$(echo "$wireless_status" | jsonfilter -e '@.*.interfaces[@.config.mode="sta"]' 2>/dev/null)
    
    # 判断中继是否开启
    if [ "$sta_count" -gt 0 ]; then
        relay_enabled=1
    else
        relay_enabled=0
    fi
    
    # 无STA接口时返回基本状态（不报错）
    if [ -z "$all_sta_info" ]; then
        json_init
        json_add_string "ssid" ""
        json_add_string "key" ""
        json_add_string "band" ""
        json_add_string "interface" ""
        json_add_string "bridge_status" "未配置"
        json_add_string "network_status" "未配置"
        json_add_string "signal" ""
        json_add_int "sta_count" 0
        json_add_boolean "relay_enabled" 0
        json_add_string "sta_section" ""
        json_dump
        return
    fi
    
    # 多STA时优先选择up=true的接口
    sta_info=""
    if [ "$sta_count" -gt 1 ]; then
        # 逐行遍历每个STA，找到up=true的
        echo "$all_sta_info" | while IFS= read -r line; do
            local net=$(echo "$line" | jsonfilter -e '@.config.network[0]' 2>/dev/null)
            if [ -n "$net" ]; then
                local up=$(ubus call network.interface."$net" status 2>/dev/null | jsonfilter -e '@.up' 2>/dev/null)
                if [ "$up" = "true" ]; then
                    echo "$line"
                    break
                fi
            fi
        done > /tmp/wx_active_sta.$$
        
        if [ -s /tmp/wx_active_sta.$$ ]; then
            sta_info=$(cat /tmp/wx_active_sta.$$)
            rm -f /tmp/wx_active_sta.$$
        fi
    fi
    
    # 如果没找到活跃的，使用第一行
    [ -z "$sta_info" ] && sta_info=$(echo "$all_sta_info" | head -1)
    
    sta_ssid=$(echo "$sta_info" | jsonfilter -e '@.config.ssid' 2>/dev/null)
    sta_key=$(echo "$sta_info" | jsonfilter -e '@.config.key' 2>/dev/null)
    sta_network=$(echo "$sta_info" | jsonfilter -e '@.config.network[0]' 2>/dev/null)
    sta_ifname=$(echo "$sta_info" | jsonfilter -e '@.ifname' 2>/dev/null)
    sta_section=$(echo "$sta_info" | jsonfilter -e '@.section' 2>/dev/null)
    
    # 获取频段 - 通过iwinfo获取频率判断
    # iwinfo输出格式: "Mode: Client  Channel: 40 (5.200 GHz)  HT Mode: NOHT"
    # 需要提取括号内的频率值(如5.200或5)，转换为MHz后判断
    local freq_ghz=$(iwinfo "$sta_ifname" info 2>/dev/null | grep -oE '\([0-9]+\.?[0-9]* GHz\)' | head -1 | grep -oE '[0-9]+\.?[0-9]*')
    if [ -n "$freq_ghz" ]; then
        # 将GHz转换为MHz进行比较（去掉小数点，如5.200变为5200）
        local freq_mhz=$(echo "$freq_ghz" | awk '{printf "%.0f", $1 * 1000}')
        if [ "$freq_mhz" -gt 5000 ] 2>/dev/null; then
            sta_band="5G"
        else
            sta_band="2.4G"
        fi
    else
        # 备用方案：通过UCI配置获取设备的band
        # 先获取section名(如wifinet2)，再从UCI查对应的device，最后获取device的band
        local section=$(echo "$sta_info" | jsonfilter -e '@.section' 2>/dev/null)
        local device=$(uci get wireless."$section".device 2>/dev/null)
        local band_cfg=$(uci get wireless."$device".band 2>/dev/null)
        case "$band_cfg" in
            2g) sta_band="2.4G" ;;
            5g) sta_band="5G" ;;
            *) sta_band="未知" ;;
        esac
    fi
    
    # 检查桥接状态
    if [ -n "$sta_ifname" ]; then
        local essid=$(iwinfo "$sta_ifname" info 2>/dev/null | awk -F'"' '/ESSID/{print $2}')
        if [ -n "$essid" ]; then
            bridge_status="连接成功 $essid"
        else
            bridge_status="连接失败"
        fi
    else
        bridge_status="接口不存在"
    fi
    
    # 检查网络状态
    if check_connectivity; then
        network_status="连接成功"
    else
        network_status="连接失败"
    fi
    
    # 获取信号强度 (dBm)
    local signal=""
    if [ -n "$sta_ifname" ]; then
        signal=$(iwinfo "$sta_ifname" assoclist 2>/dev/null | awk 'NR==1 {print $2}')
    fi
    
    json_init
    json_add_string "ssid" "$sta_ssid"
    json_add_string "key" "$sta_key"
    json_add_string "band" "$sta_band"
    json_add_string "interface" "${sta_network:-unknown}"
    json_add_string "bridge_status" "$bridge_status"
    json_add_string "network_status" "$network_status"
    json_add_string "signal" "${signal:-unknown}"
    json_add_int "sta_count" "$sta_count"
    json_add_boolean "relay_enabled" "$relay_enabled"
    json_add_string "sta_section" "${sta_section:-}"
    json_dump
}

# 获取无线设置
get_wireless_settings() {
    local device_2g device_5g
    
    # 查找2.4G和5G设备
    for dev in $(uci show wireless | grep "\.band=" | cut -d. -f2); do
        local band=$(uci get wireless."$dev".band 2>/dev/null)
        case "$band" in
            2g) device_2g="$dev" ;;
            5g) device_5g="$dev" ;;
        esac
    done
    
    json_init
    
    # 2.4G设置
    if [ -n "$device_2g" ]; then
        json_add_string "disabled_2g" "$(uci get wireless.default_$device_2g.disabled 2>/dev/null || echo 'false')"
        json_add_string "ssid_2g" "$(uci get wireless.default_$device_2g.ssid 2>/dev/null)"
        json_add_string "key_2g" "$(uci get wireless.default_$device_2g.key 2>/dev/null)"
        json_add_string "channel_2g" "$(uci get wireless.$device_2g.channel 2>/dev/null)"
        json_add_string "htmode_2g" "$(uci get wireless.$device_2g.htmode 2>/dev/null)"
        json_add_string "hidden_2g" "$(uci get wireless.default_$device_2g.hidden 2>/dev/null || echo 'false')"
    fi
    
    # 5G设置
    if [ -n "$device_5g" ]; then
        json_add_string "disabled_5g" "$(uci get wireless.default_$device_5g.disabled 2>/dev/null || echo 'false')"
        json_add_string "ssid_5g" "$(uci get wireless.default_$device_5g.ssid 2>/dev/null)"
        json_add_string "key_5g" "$(uci get wireless.default_$device_5g.key 2>/dev/null)"
        json_add_string "channel_5g" "$(uci get wireless.$device_5g.channel 2>/dev/null)"
        json_add_string "htmode_5g" "$(uci get wireless.$device_5g.htmode 2>/dev/null)"
        json_add_string "hidden_5g" "$(uci get wireless.default_$device_5g.hidden 2>/dev/null || echo 'false')"
    fi
    
    json_dump
}

# 保存无线设置
save_wireless_settings() {
    local device_2g device_5g
    
    # 查找设备
    for dev in $(uci show wireless | grep "\.band=" | cut -d. -f2); do
        local band=$(uci get wireless."$dev".band 2>/dev/null)
        case "$band" in
            2g) device_2g="$dev" ;;
            5g) device_5g="$dev" ;;
        esac
    done
    
    # 解析输入参数
    json_load "$1"
    
    local d2g d5g k2g k5g
    json_get_var d2g disabled_2g
    json_get_var d5g disabled_5g
    json_get_var k2g key_2g
    json_get_var k5g key_5g
    
    # P0 安全校验：禁止同时关闭两个 WiFi
    if [ "$d2g" = "1" ] && [ "$d5g" = "1" ]; then
        json_init
        json_add_string "status" "error"
        json_add_string "message" "至少需开启一个无线网络，以防无法访问"
        json_dump
        return
    fi
    
    # 密码合法性校验
    if [ "$d2g" = "0" ] && [ -n "$k2g" ]; then
        if ! validate_password "$k2g"; then
            json_init
            json_add_string "status" "error"
            json_add_string "message" "2.4G WiFi密码格式错误：只能使用英文、数字和符号(8-63位)"
            json_dump
            return
        fi
    fi
    
    if [ "$d5g" = "0" ] && [ -n "$k5g" ]; then
        if ! validate_password "$k5g"; then
            json_init
            json_add_string "status" "error"
            json_add_string "message" "5G WiFi密码格式错误：只能使用英文、数字和符号(8-63位)"
            json_dump
            return
        fi
    fi

    # 保存2.4G设置
    if [ -n "$device_2g" ]; then
        local val
        json_get_var val disabled_2g && uci set wireless.default_$device_2g.disabled="$val"
        json_get_var val ssid_2g && uci set wireless.default_$device_2g.ssid="$val"
        json_get_var val key_2g && uci set wireless.default_$device_2g.key="$val"
        json_get_var val channel_2g && uci set wireless.$device_2g.channel="$val"
        json_get_var val htmode_2g && uci set wireless.$device_2g.htmode="$val"
        json_get_var val hidden_2g && {
            if [ "$val" = "true" ] || [ "$val" = "1" ]; then
                uci set wireless.default_$device_2g.hidden="1"
            else
                uci delete wireless.default_$device_2g.hidden 2>/dev/null
            fi
        }
    fi
    
    # 保存5G设置
    if [ -n "$device_5g" ]; then
        local val
        json_get_var val disabled_5g && uci set wireless.default_$device_5g.disabled="$val"
        json_get_var val ssid_5g && uci set wireless.default_$device_5g.ssid="$val"
        json_get_var val key_5g && uci set wireless.default_$device_5g.key="$val"
        json_get_var val channel_5g && uci set wireless.$device_5g.channel="$val"
        json_get_var val htmode_5g && uci set wireless.$device_5g.htmode="$val"
        json_get_var val hidden_5g && {
            if [ "$val" = "true" ] || [ "$val" = "1" ]; then
                uci set wireless.default_$device_5g.hidden="1"
            else
                uci delete wireless.default_$device_5g.hidden 2>/dev/null
            fi
        }
    fi
    
    uci commit wireless
    wifi reload
    
    json_init
    json_add_string "status" "success"
    json_add_string "message" "无线设置已保存"
    json_dump
}

# 连接WiFi
connect() {
    json_load "$1"
    
    local ssid encryption key band
    json_get_var ssid ssid
    json_get_var encryption encryption
    json_get_var key key
    json_get_var band band
    
    # 校验密码
    if [ "$encryption" != "none" ] && [ "$encryption" != "owe" ]; then
        if ! validate_password "$key"; then
            json_init
            json_add_string "status" "error"
            json_add_string "message" "WiFi密码格式错误：只能使用英文、数字和符号(8-63位)"
            json_dump
            return
        fi
    fi
    
    # 标准化band格式
    case "$band" in
        2g|2G|2.4g|2.4G) band="2g" ;;
        5g|5G) band="5g" ;;
    esac
    
    # 查找对应频段的设备
    local target_device
    for dev in $(uci show wireless | grep "\.band=" | cut -d. -f2); do
        local dev_band=$(uci get wireless."$dev".band 2>/dev/null)
        if [ "$dev_band" = "$band" ]; then
            target_device="$dev"
            break
        fi
    done
    
    if [ -z "$target_device" ]; then
        json_init
        json_add_string "status" "error"
        json_add_string "message" "未找到对应频段的设备"
        json_dump
        return
    fi
    
    # 查找STA接口
    local sta_section=$(get_sta_section)
    
    # 如果没有STA接口，自动创建中继模式
    if [ -z "$sta_section" ]; then
        log_message "未找到STA接口，自动创建中继模式"
        sta_section="wifinet_sta"
        
        # 1. 创建无线STA接口
        uci set wireless.wifinet_sta=wifi-iface
        uci set wireless.wifinet_sta.device="$target_device"
        uci set wireless.wifinet_sta.mode='sta'
        uci set wireless.wifinet_sta.network='wwan'
        uci set wireless.wifinet_sta.ssid="$ssid"
        uci set wireless.wifinet_sta.encryption="$encryption"
        [ -n "$key" ] && uci set wireless.wifinet_sta.key="$key"
        
        # 2. 创建网络接口
        uci set network.wwan=interface
        uci set network.wwan.proto='dhcp'
        
        # 3. 动态获取WAN zone并添加wwan
        local wan_zone=$(uci show firewall | grep "name='wan'" | head -1 | cut -d. -f2)
        [ -z "$wan_zone" ] && wan_zone="@zone[1]"
        uci add_list firewall."$wan_zone".network='wwan'
        
        # 4. 提交并应用
        uci commit wireless
        uci commit network
        uci commit firewall
        
        # 5. 重载网络（最优方案：热重载 + 防火墙）
        wifi reload
        sleep 3
        /etc/init.d/network reload
        /etc/init.d/firewall reload
        
        log_message "中继模式已自动创建并连接: $ssid"
    else
        # STA接口已存在，直接更新配置
        uci set wireless."$sta_section".device="$target_device"
        uci set wireless."$sta_section".ssid="$ssid"
        uci set wireless."$sta_section".encryption="$encryption"
        uci set wireless."$sta_section".key="$key"
        uci commit wireless
        wifi reload
        
        log_message "手动连接热点: $ssid 密码: $key 频段: $band 加密: $encryption"
    fi
    
    json_init
    json_add_string "status" "success"
    json_add_string "message" "WiFi配置已更新"
    json_dump
}

# 获取已知热点列表
get_known_networks() {
    init_config
    cat "$CONFIG_FILE"
}

# 保存热点配置
save_network() {
    init_config
    json_load "$1"
    
    local name encryption password band
    json_get_var name name
    json_get_var encryption encryption
    json_get_var password password
    json_get_var band band
    
    # 校验密码
    if [ "$encryption" != "none" ] && [ "$encryption" != "owe" ]; then
        if ! validate_password "$password"; then
            json_init
            json_add_string "status" "error"
            json_add_string "message" "WiFi密码格式错误：只能使用英文、数字和符号(8-63位)"
            json_dump
            return
        fi
    fi
    
    local current_time=$(date "+%Y-%m-%d %H:%M:%S")
    
    # 使用辅助函数更新配置（兼容 OpenWRT）
    json_save_wifi "$name" "$encryption" "$password" "$band" "$current_time"
    
    log_message "保存热点: $name 密码: $password 频段: $band 加密: $encryption"
    
    json_init
    json_add_string "status" "success"
    json_add_string "message" "热点已保存"
    json_dump
}

# 删除热点
delete_networks() {
    init_config
    json_load "$1"
    
    local names
    json_get_values names names
    
    for name in $names; do
        json_delete_wifi "$name"
        log_message "删除热点: $name"
    done
    
    json_init
    json_add_string "status" "success"
    json_add_string "message" "热点已删除"
    json_dump
}

# 保存排序 (仅更新 wifi 列表，保留其他状态)
save_order() {
    init_config
    
    # 使用 jshn 解析输入的 wifi 数组
    json_load "$1"
    
    local wifi_array_type
    json_get_type wifi_array_type wifi
    
    if [ "$wifi_array_type" != "array" ]; then
        json_init
        json_add_string "status" "error"
        json_add_string "message" "无效的WiFi列表数据"
        json_dump
        return
    fi
    
    # 构建新的 wifi JSON 数组
    local new_wifi="["
    local idx=0
    json_select wifi
    while json_get_type item_type $idx && [ "$item_type" = "object" ]; do
        json_select $idx
        local name encryption password band last_updated
        json_get_var name name
        json_get_var encryption encryption
        json_get_var password password
        json_get_var band band
        json_get_var last_updated last_updated
        json_select ..
        
        [ $idx -gt 0 ] && new_wifi="$new_wifi,"
        new_wifi="$new_wifi{\"name\":\"$name\",\"encryption\":\"$encryption\",\"password\":\"$password\",\"band\":\"$band\",\"last_updated\":\"$last_updated\"}"
        idx=$((idx + 1))
    done
    new_wifi="$new_wifi]"
    
    # 使用辅助函数重写配置
    json_rewrite_wifi "$new_wifi"
    
    json_init
    json_add_string "status" "success"
    json_add_string "message" "排序已保存"
    json_dump
}


# wxpusher推送消息（内置配置）
# 参数1: 标题(summary)  参数2: 内容(content)
push_message() {
    # 检查推送开关
    [ "$WXPUSHER_ENABLED" != "1" ] && return
    
    local summary="$1"
    local content="$2"
    
    # 发送推送
    local json_data="{\"appToken\":\"$WX_APP_TOKEN\",\"summary\":\"$summary\",\"content\":\"$content\",\"uids\":[\"$WX_MY_UID\"]}"
    curl -s -X POST -H "Content-Type: application/json" \
        -d "$json_data" \
        "$WXPUSHER_API_URL" >/dev/null 2>&1
}

# 测试推送消息
test_push() {
    init_config
    
    # 检查配置
    if [ -z "$WX_APP_TOKEN" ] || [ -z "$WX_MY_UID" ]; then
        json_init
        json_add_string "status" "error"
        json_add_string "message" "请先配置应用Token和用户UID"
        json_dump
        return
    fi
    
    # 获取设备名称
    local device_name=$(uci get system.@system[0].hostname 2>/dev/null || echo "路由器")
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    # 发送测试消息
    local json_data="{\"appToken\":\"$WX_APP_TOKEN\",\"summary\":\"[$device_name] 测试推送\",\"content\":\"这是一条测试消息\\n时间: $timestamp\",\"uids\":[\"$WX_MY_UID\"]}"
    local response=$(curl -s -X POST -H "Content-Type: application/json" \
        -d "$json_data" \
        "$WXPUSHER_API_URL" 2>&1)
    
    # 检查响应
    if echo "$response" | grep -q '"success":true'; then
        json_init
        json_add_string "status" "success"
        json_add_string "message" "测试消息已发送"
        json_dump
    else
        json_init
        json_add_string "status" "error"
        json_add_string "message" "发送失败，请检查配置"
        json_dump
    fi
}

# 自动切换热点
auto_switch() {
    init_config
    
    # 动态获取STA接口的network名称
    local sta_network=$(get_single_sta_network)
    
    # 检查STA接口数量
    if [ "$STA_NETWORK_COUNT" -eq 0 ]; then
        log_message "错误：未检测到STA接口"
        json_init
        json_add_string "status" "error"
        json_add_string "message" "未检测到STA接口"
        json_dump
        return
    fi
    
    if [ "$STA_NETWORK_COUNT" -gt 1 ]; then
        log_message "错误：检测到多个STA接口($STA_NETWORK_COUNT个)，请删除多余接口"
        json_init
        json_add_string "status" "error"
        json_add_string "message" "检测到${STA_NETWORK_COUNT}个STA接口，请删除多余接口"
        json_dump
        return
    fi
    
    # 获取当前连接的热点名称
    local sta_section=$(get_sta_section)
    local current_ssid=$(uci get wireless."$sta_section".ssid 2>/dev/null)
    
    # 先检查热点数量（必须有2个以上才能切换）
    local wifi_count=$(json_get_wifi_count)
    
    if [ -z "$wifi_count" ] || [ "$wifi_count" -eq 0 ]; then
        log_message "错误：没有已知热点可切换"
        json_init
        json_add_string "status" "error"
        json_add_string "message" "没有已知热点可切换"
        json_dump
        return
    fi
    
    if [ "$wifi_count" -eq 1 ]; then
        log_message "只有一个热点，无法切换"
        json_init
        json_add_string "status" "error"
        json_add_string "message" "需要配置2个以上热点才能切换"
        json_dump
        return
    fi
    
    # 再检查网络连通性
    if check_connectivity; then
        json_init
        json_add_string "status" "success"
        json_add_string "message" "$current_ssid 网络正常，无需切换"
        json_dump
        return
    fi
    
    log_message "网络不通，开始切换 (当前: $current_ssid)"
    
    # 检查STA接口
    if [ -z "$sta_section" ]; then
        log_message "错误：未找到STA接口"
        json_init
        json_add_string "status" "error"
        json_add_string "message" "未找到STA接口"
        json_dump
        return
    fi
    
    # 遍历热点尝试连接
    local i=0
    while [ $i -lt $wifi_count ]; do
        local name=$(json_get_wifi_field $i "name")
        local encryption=$(json_get_wifi_field $i "encryption")
        local password=$(json_get_wifi_field $i "password")
        local band=$(json_get_wifi_field $i "band")
        local last_updated=$(json_get_wifi_field $i "last_updated")
        local wifi_index=$i
        
        i=$((i + 1))
        
        [ -z "$name" ] || [ "$name" = "null" ] && continue
        
        # 跳过当前已连接的热点
        if [ "$name" = "$current_ssid" ]; then
            log_message "跳过当前热点: $name"
            continue
        fi
        
        # 检查是否在冷却时间内（防止短时间重复连接）
        if [ -n "$last_updated" ] && [ "$last_updated" != "null" ]; then
            # 将 "2025-06-10 12:30:45" 转换为 busybox 兼容格式 "2025-06-10T12:30:45"
            local last_updated_iso=$(echo "$last_updated" | sed 's/ /T/')
            local last_ts=$(date -d "$last_updated_iso" +%s 2>/dev/null)
            if [ -n "$last_ts" ]; then
                local now_ts=$(date +%s)
                local diff=$((now_ts - last_ts))
                if [ $diff -lt $RETRY_WIFI_INTERVAL ]; then
                    local remain=$((RETRY_WIFI_INTERVAL - diff))
                    log_message "跳过 $name: 冷却中，还需等待 ${remain} 秒"
                    continue
                fi
            fi
        fi
        
        # 标准化band格式
        case "$band" in
            2g|2G|2.4g|2.4G) band="2g" ;;
            5g|5G) band="5g" ;;
        esac
        
        # 查找对应频段设备
        local target_device=""
        for dev in $(uci show wireless | grep "\.band=" | cut -d. -f2); do
            local dev_band=$(uci get wireless."$dev".band 2>/dev/null)
            if [ "$dev_band" = "$band" ]; then
                target_device="$dev"
                break
            fi
        done
        
        if [ -z "$target_device" ]; then
            log_message "未找到频段 $band 对应的设备，跳过 $name"
            continue
        fi
        
        log_message "尝试连接: $name (频段: $band, 加密: $encryption)"
        
        # 更新last_updated时间戳（防止短时间内重复尝试）
        local current_time=$(date "+%Y-%m-%d %H:%M:%S")
        json_update_wifi_timestamp "$wifi_index" "$current_time"
        
        # 配置并重启WiFi
        uci set wireless."$sta_section".device="$target_device"
        uci set wireless."$sta_section".ssid="$name"
        uci set wireless."$sta_section".encryption="$encryption"
        uci set wireless."$sta_section".key="$password"
        uci commit wireless
        wifi reload
        
        # 核心逻辑修改：统计 SWITCH_COUNT (wifi 重载次数)
        # 只要执行了 wifi reload，无论后续连接成功与否，都要累加计数
        # 这是为了准确追踪无线驱动被重置的次数，防范累积性故障
        local switch_count=$(json_get_cq_times)
        switch_count=$((switch_count + 1))
        json_set_cq_times "$switch_count"
        log_message "WiFi配置已应用，累计切换次数: $switch_count"
        
        log_message "等待设备就绪..."
        
        # 等待设备名称获取
        local sta_ifname=""
        local retry=0
        while [ $retry -lt $AUTO_SWITCH_MAX_RETRIES ]; do
            sleep $((CHECK_WAIT_TIME + 1))
            sta_ifname=$(ubus call network.interface."$sta_network" status 2>/dev/null | jsonfilter -e '@.device' 2>/dev/null)
            if [ -n "$sta_ifname" ]; then
                log_message "获取到设备名称: $sta_ifname"
                break
            fi
            retry=$((retry + 1))
            log_message "等待设备名称... ($retry/$AUTO_SWITCH_MAX_RETRIES)"
        done
        
        if [ -z "$sta_ifname" ]; then
            log_message "获取设备名称失败，尝试下一个热点"
            continue
        fi
        
        # 等待WiFi连接
        retry=0
        local connected=0
        log_message "等待WiFi连接..."
        while [ $retry -lt $AUTO_SWITCH_MAX_RETRIES ]; do
            sleep $CHECK_WAIT_TIME
            local wifi_state=$(iwinfo "$sta_ifname" info 2>/dev/null | grep -o 'ESSID: "[^"]*"' | cut -d'"' -f2)
            if [ "$wifi_state" = "$name" ]; then
                connected=1
                log_message "WiFi连接成功: $name"
                break
            fi
            retry=$((retry + 1))
            log_message "等待WiFi连接... ($retry/$AUTO_SWITCH_MAX_RETRIES)"
        done
        
        if [ $connected -eq 0 ]; then
            log_message "WiFi连接失败: $name，尝试下一个热点"
            continue
        fi
        
        # 检查网络连通性
        retry=0
        log_message "检测网络连通性..."
        while [ $retry -lt $AUTO_SWITCH_MAX_RETRIES ]; do
            sleep $CHECK_WAIT_TIME
            if check_connectivity; then
                log_message "网络已连通！切换成功: $name"
                # 注意：切换成功不清零计数，因为 wifi reload 本身就有累积副作用
                
                # 发送推送通知
                local device_name=$(uci get system.@system[0].hostname 2>/dev/null || echo "路由器")
                push_message "[$device_name] 通知" "已切换到 $name，网络已恢复正常"
                
                json_init
                json_add_string "status" "success"
                json_add_string "message" "已切换到 $name"
                json_dump
                return
            fi
            retry=$((retry + 1))
            log_message "网络检测... ($retry/$AUTO_SWITCH_MAX_RETRIES)"
        done
        
        log_message "网络不通: $name，尝试下一个热点"
    done
    
    # 统计并检查自动重启
    local switch_count=$(json_get_cq_times)
    
    log_message "自动切换循环结束，当前累计切换次数: $switch_count/$RESTART_THRESHOLD"
    
    # 检查是否达到重启阈值
    if [ "$switch_count" -ge "$RESTART_THRESHOLD" ]; then
        log_message "⚠️ 累计切换次数达到阈值($switch_count/$RESTART_THRESHOLD)，执行自动重启以恢复无线网卡状态"
        
        # 重置切换计数
        json_set_cq_times 0
        
        # 缓冲一段时间后重启
        ( sleep "$REBOOT_DELAY_TIME" && reboot ) &
        
        json_init
        json_add_string "status" "warning"
        json_add_string "message" "累计且频繁切换次数过多，系统即将自动重启以保护设备"
        json_dump
        return
    fi
    
    json_init
    json_add_string "status" "error"
    json_add_string "message" "所有热点尝试失败"
    json_dump
}

# 获取日志
get_log() {
    json_load "$1"
    local lines=""
    json_get_var lines lines
    
    # 默认返回最后50行
    [ -z "$lines" ] && lines=50
    
    if [ ! -f "$LOG_FILE" ]; then
        json_init
        json_add_string "status" "success"
        json_add_string "log" ""
        json_dump
        return
    fi
    
    local log_content=$(tail -n "$lines" "$LOG_FILE" 2>/dev/null)
    
    json_init
    json_add_string "status" "success"
    json_add_string "log" "$log_content"
    json_dump
}

# 清空日志
clear_log() {
    echo "" > "$LOG_FILE"
    json_init
    json_add_string "status" "success"
    json_add_string "message" "日志已清空"
    json_dump
}



# RPC方法列表
# 获取重试状态
get_retry_status() {
    init_config
    
    # 从配置文件读取重试状态
    local cq_times
    
    cq_times=$(json_get_cq_times)
    
    json_init
    json_add_int "cq_times" "$cq_times"
    json_add_int "max_retries" "$AUTO_SWITCH_MAX_RETRIES"
    json_add_int "restart_threshold" "$RESTART_THRESHOLD"
    json_dump
}

# 重置重试计数
reset_retry_count() {
    init_config
    
    # 重置配置文件中的CQ_TIMES为0
    json_set_cq_times 0
    
    log_message "重试计数已重置为0"
    
    json_init
    json_add_string "status" "success"
    json_add_string "message" "重试计数已重置"
    json_dump
}

# 动态获取指定频段的AP接口名
# 参数: band (2g/5g)
# 返回: 接口名 (如 ra0, phy0-ap0 等)
get_ap_ifname_by_band() {
    local target_band="$1"
    local wireless_status=$(ubus call network.wireless status 2>/dev/null)
    
    # 遍历所有 device，找到匹配 band 的
    for dev in $(uci show wireless | grep "\.band=" | cut -d. -f2); do
        local dev_band=$(uci get wireless."$dev".band 2>/dev/null)
        if [ "$dev_band" = "$target_band" ]; then
            # 从 wireless status 获取该 device 下的第一个 AP 接口
            local ifname=$(echo "$wireless_status" | jsonfilter -e "@[\"$dev\"].interfaces[@.config.mode=\"ap\"].ifname" 2>/dev/null | head -1)
            if [ -n "$ifname" ]; then
                echo "$ifname"
                return 0
            fi
        fi
    done
    return 1
}

# 扫描附近WiFi网络
# 参数: band (2g/5g)
# 注意: ubus call iwinfo scan 存在 SSID 缓冲区污染 bug，改用 iwinfo scan 解析文本
scan_wifi() {
    json_load "$1"
    
    local band
    json_get_var band band
    
    # 规范化 band 参数
    local cache_band="2g"
    case "$band" in
        5g|5G) cache_band="5g" ;;
    esac
    
    # 动态获取扫描接口名
    local scan_device=$(get_ap_ifname_by_band "$cache_band")
    if [ -z "$scan_device" ]; then
        json_init
        json_add_array "results"
        json_close_array
        json_add_string "error" "未找到${cache_band}频段接口"
        json_dump
        return
    fi
    
    local cache_file="/tmp/wifi_scan_${cache_band}.json"
    
    # 使用 iwinfo scan 并解析文本输出为 JSON（避免 ubus 的 SSID 乱码 bug）
    local scan_output
    scan_output=$(iwinfo "$scan_device" scan 2>/dev/null)
    
    if [ -z "$scan_output" ]; then
        echo '{"results":[]}' > "$cache_file"
        echo '{"results":[]}'
        return
    fi
    
    # 解析 iwinfo scan 文本输出为 JSON（兼容 BusyBox awk）
    echo "$scan_output" | awk '
    BEGIN { printf "{\"results\":[" }
    /^Cell/ {
        if (NR > 1 && bssid != "") print_entry()
        # 提取 BSSID (Cell XX - Address: XX:XX:XX:XX:XX:XX)
        for (i=1; i<=NF; i++) if ($i ~ /^[0-9A-Fa-f]{2}:/) bssid = $i
        ssid = ""; channel = 0; signal = 0; quality = 0
        enc_enabled = "false"; wpa_vers = ""
    }
    /ESSID:/ {
        if ($0 ~ /unknown/) ssid = ""
        else {
            sub(/.*ESSID: "/, ""); sub(/".*/, "")
            ssid = $0
            gsub(/\\/, "\\\\", ssid); gsub(/"/, "\\\"", ssid)
        }
    }
    /Band:.*Channel:/ {
        # 只匹配 "Band: unknown  Channel: 11" 这种行，避免匹配 "Primary Channel: 0"
        for (i=1; i<=NF; i++) {
            if ($i == "Channel:") { channel = $(i+1); break }
        }
    }
    /Signal:/ {
        for (i=1; i<=NF; i++) {
            if ($i == "Signal:") signal = $(i+1)
            if ($i == "Quality:") { split($(i+1), q, "/"); quality = q[1] }
        }
    }
    /Encryption:/ {
        if ($0 ~ /none/) { enc_enabled = "false"; wpa_vers = "" }
        else {
            enc_enabled = "true"
            if ($0 ~ /mixed/ || ($0 ~ /WPA2/ && $0 ~ /WPA[^2]/)) wpa_vers = "[1,2]"
            else if ($0 ~ /WPA2/) wpa_vers = "[2]"
            else if ($0 ~ /WPA/) wpa_vers = "[1]"
        }
    }
    function print_entry() {
        if (first_done) printf ","
        first_done = 1
        printf "{"
        if (ssid != "") printf "\"ssid\":\"%s\",", ssid
        printf "\"bssid\":\"%s\",", bssid
        printf "\"channel\":%d,", channel
        printf "\"signal\":%d,", signal
        printf "\"quality\":%d,", quality
        printf "\"quality_max\":100,"
        printf "\"encryption\":{\"enabled\":%s", enc_enabled
        if (enc_enabled == "true" && wpa_vers != "") printf ",\"wpa\":%s,\"authentication\":[\"psk\"]", wpa_vers
        printf "}}"
    }
    END { if (bssid != "") print_entry(); print "]}" }
    ' | tee "$cache_file"
}

# 获取缓存的扫描结果（永久有效，返回扫描时间让用户自行判断）
get_cached_scan() {
    json_load "$1"
    
    local band
    json_get_var band band
    
    local cache_band="2g"
    case "$band" in
        5g|5G) cache_band="5g" ;;
    esac
    
    local cache_file="/tmp/wifi_scan_${cache_band}.json"
    
    if [ -f "$cache_file" ]; then
        # 获取文件修改时间作为扫描时间
        local scan_time=$(date -r "$cache_file" "+%Y-%m-%d %H:%M:%S" 2>/dev/null || echo "")
        local cache_content=$(cat "$cache_file" | tr -d '\n')
        # 注入扫描时间到JSON（移除换行符确保匹配）
        echo "$cache_content" | sed 's/}$/,"scan_time":"'"$scan_time"'"}/'
    else
        echo '{"results":[]}'
    fi
}

# 获取系统配置
get_settings() {
    if [ ! -f "$SETTINGS_FILE" ]; then
        json_init
        json_add_string "status" "error"
        json_add_string "message" "配置文件不存在"
        json_dump
        return
    fi
    
    json_init
    json_add_string "status" "success"
    
    # WxPusher 推送配置
    json_add_int "wxpusher_enabled" "$WXPUSHER_ENABLED"
    json_add_string "wx_app_token" "$WX_APP_TOKEN"
    json_add_string "wx_my_uid" "$WX_MY_UID"
    json_add_string "wxpusher_api_url" "$WXPUSHER_API_URL"
    
    # 网络检测配置
    json_add_string "ping_target" "$PING_TARGET"
    
    # 自动切换配置
    json_add_int "auto_switch_max_retries" "$AUTO_SWITCH_MAX_RETRIES"
    json_add_int "retry_wifi_interval" "$RETRY_WIFI_INTERVAL"
    json_add_int "restart_threshold" "$RESTART_THRESHOLD"
    
    # 系统配置
    json_add_int "show_wxpusher" "${SHOW_WXPUSHER:-0}"
    
    json_dump
}

# 保存系统配置
save_settings() {
    json_load "$1"
    
    # 读取所有配置值
    local wxpusher_enabled wx_app_token wx_my_uid wxpusher_api_url
    local ping_target auto_switch_max_retries
    local retry_wifi_interval restart_threshold
    
    json_get_var wxpusher_enabled wxpusher_enabled
    json_get_var wx_app_token wx_app_token
    json_get_var wx_my_uid wx_my_uid
    json_get_var wxpusher_api_url wxpusher_api_url
    json_get_var ping_target ping_target
    json_get_var auto_switch_max_retries auto_switch_max_retries
    json_get_var retry_wifi_interval retry_wifi_interval
    json_get_var restart_threshold restart_threshold
    
    # 写入配置文件
    cat > "$SETTINGS_FILE" << EOF
# ============================================================
# WX-Wireless 配置文件
# 路径: /etc/wx/wx_settings.conf
# 修改后无需重启，脚本会自动加载
# ============================================================

# === WxPusher 微信推送配置 ===
# 获取方式: https://wxpusher.zjiecode.com/admin/login
WXPUSHER_ENABLED=${wxpusher_enabled:-0}                    # 推送开关 (1=开启, 0=关闭)
WX_APP_TOKEN="${wx_app_token}"  # 应用Token
WX_MY_UID="${wx_my_uid}"       # 用户UID
WXPUSHER_API_URL="${wxpusher_api_url:-https://wxpusher.zjiecode.com/api/send/message}"

# === 网络检测配置 ===
PING_TARGET="${ping_target:-223.5.5.5}"               # 网络连通性检测IP

# === 自动切换配置 ===
AUTO_SWITCH_MAX_RETRIES=${auto_switch_max_retries:-25}            # 连接/检测最大重试次数
RETRY_WIFI_INTERVAL=${retry_wifi_interval:-688}               # 相同热点重试冷却时间 (秒)
RESTART_THRESHOLD=${restart_threshold:-10}                  # 累计失败后自动重启阈值

EOF
    
    # 重新加载配置
    . "$SETTINGS_FILE"
    
    log_message "系统配置已更新"
    
    json_init
    json_add_string "status" "success"
    json_add_string "message" "配置已保存"
    json_dump
}

# 开启中继模式
enable_relay() {
    json_load "$1"
    
    local ssid key encryption band
    json_get_var ssid ssid
    json_get_var key key
    json_get_var encryption encryption
    json_get_var band band
    
    # 默认值
    [ -z "$encryption" ] && encryption="psk2"
    [ -z "$band" ] && band="5g"
    
    # 标准化band格式
    case "$band" in
        2g|2G|2.4g|2.4G) band="2g" ;;
        5g|5G) band="5g" ;;
    esac
    
    # 检查是否已有STA接口
    local sta_count=$(ubus call network.wireless status 2>/dev/null | jsonfilter -e '@.*.interfaces[@.config.mode="sta"]' 2>/dev/null | grep -c '"section"')
    if [ "$sta_count" -gt 0 ]; then
        json_init
        json_add_string "status" "error"
        json_add_string "message" "中继模式已开启，请先关闭现有中继"
        json_dump
        return
    fi
    
    # 校验参数
    if [ -z "$ssid" ]; then
        json_init
        json_add_string "status" "error"
        json_add_string "message" "请输入WiFi名称"
        json_dump
        return
    fi
    
    if [ "$encryption" != "none" ] && [ "$encryption" != "owe" ]; then
        if ! validate_password "$key"; then
            json_init
            json_add_string "status" "error"
            json_add_string "message" "WiFi密码格式错误：只能使用英文、数字和符号(8-63位)"
            json_dump
            return
        fi
    fi
    
    # 动态获取对应频段的设备
    local target_device
    for dev in $(uci show wireless | grep "\.band=" | cut -d. -f2); do
        local dev_band=$(uci get wireless."$dev".band 2>/dev/null)
        if [ "$dev_band" = "$band" ]; then
            target_device="$dev"
            break
        fi
    done
    
    if [ -z "$target_device" ]; then
        json_init
        json_add_string "status" "error"
        json_add_string "message" "未找到对应频段的设备"
        json_dump
        return
    fi
    
    log_message "开启中继模式: SSID=$ssid 频段=$band 设备=$target_device"
    
    # 1. 创建无线STA接口
    uci set wireless.wifinet_sta=wifi-iface
    uci set wireless.wifinet_sta.device="$target_device"
    uci set wireless.wifinet_sta.mode='sta'
    uci set wireless.wifinet_sta.network='wwan'
    uci set wireless.wifinet_sta.ssid="$ssid"
    uci set wireless.wifinet_sta.encryption="$encryption"
    [ -n "$key" ] && uci set wireless.wifinet_sta.key="$key"
    
    # 2. 创建网络接口
    uci set network.wwan=interface
    uci set network.wwan.proto='dhcp'
    
    # 3. 动态获取WAN zone并添加wwan
    local wan_zone=$(uci show firewall | grep "name='wan'" | head -1 | cut -d. -f2)
    [ -z "$wan_zone" ] && wan_zone="@zone[1]"
    uci add_list firewall."$wan_zone".network='wwan'
    
    # 4. 提交并应用
    uci commit wireless
    uci commit network
    uci commit firewall
    
    # 5. 重载网络（最优方案：热重载 + 防火墙）
    wifi reload
    sleep 3
    /etc/init.d/network reload
    /etc/init.d/firewall reload
    
    log_message "中继模式已开启"
    
    json_init
    json_add_string "status" "success"
    json_add_string "message" "中继模式已开启，正在连接..."
    json_dump
}

# 关闭中继模式
disable_relay() {
    # 检查是否有STA接口（兼容mode=sta和mode='sta'两种格式）
    local sta_section=$(uci show wireless | grep -E "mode='?sta'?" | head -1 | cut -d. -f2)
    
    if [ -z "$sta_section" ]; then
        json_init
        json_add_string "status" "error"
        json_add_string "message" "中继模式未开启"
        json_dump
        return
    fi
    
    # 获取对应的network名称
    local sta_network=$(uci get wireless."$sta_section".network 2>/dev/null)
    
    log_message "关闭中继模式: section=$sta_section network=$sta_network"
    
    # 1. 删除无线STA接口
    uci delete wireless."$sta_section"
    
    # 2. 删除网络接口
    if [ -n "$sta_network" ]; then
        uci delete network."$sta_network" 2>/dev/null
        # 3. 动态获取WAN zone并移除
        local wan_zone=$(uci show firewall | grep "name='wan'" | head -1 | cut -d. -f2)
        [ -z "$wan_zone" ] && wan_zone="@zone[1]"
        uci del_list firewall."$wan_zone".network="$sta_network" 2>/dev/null
    fi
    
    # 4. 提交配置
    uci commit wireless
    uci commit network
    uci commit firewall
    
    # 5. 重载网络（最优方案：热重载 + 防火墙）
    wifi reload
    sleep 3
    /etc/init.d/network reload
    /etc/init.d/firewall reload
    
    log_message "中继模式已关闭"
    
    json_init
    json_add_string "status" "success"
    json_add_string "message" "中继模式已关闭"
    json_dump
}

case "$1" in
    list)
        echo '{"get_status":{},"get_wireless_settings":{},"save_wireless_settings":{"settings":"object"},"connect":{"ssid":"string","encryption":"string","key":"string","band":"string"},"get_known_networks":{},"save_network":{"name":"string","encryption":"string","password":"string","band":"string"},"delete_networks":{"names":"array"},"save_order":{"wifi":"array"},"auto_switch":{},"get_log":{"lines":"number"},"clear_log":{},"get_retry_status":{},"reset_retry_count":{},"scan_wifi":{"band":"string"},"get_cached_scan":{"band":"string"},"get_settings":{},"save_settings":{"settings":"object"},"test_push":{},"enable_relay":{"ssid":"string","key":"string","encryption":"string","band":"string"},"disable_relay":{}}'
        ;;
    call)
        case "$2" in
            get_status) get_status ;;
            get_wireless_settings) get_wireless_settings ;;
            save_wireless_settings) save_wireless_settings "$3" ;;
            connect) connect "$3" ;;
            get_known_networks) get_known_networks ;;
            save_network) save_network "$3" ;;
            delete_networks) delete_networks "$3" ;;
            save_order) save_order "$3" ;;
            auto_switch) auto_switch ;;
            get_log) get_log "$3" ;;
            clear_log) clear_log ;;
            get_retry_status) get_retry_status ;;
            reset_retry_count) reset_retry_count ;;
            scan_wifi) scan_wifi "$3" ;;
            get_cached_scan) get_cached_scan "$3" ;;
            get_settings) get_settings ;;
            save_settings) save_settings "$3" ;;
            test_push) test_push ;;
            enable_relay) enable_relay "$3" ;;
            disable_relay) disable_relay ;;
        esac
        ;;
esac

